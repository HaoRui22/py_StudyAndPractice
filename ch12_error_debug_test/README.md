- 12.1
  - [do_try.py](./do_try.py)
  - [err.py](./err.py)
  - [err_logging.py](./err_logging.py)
  - [err_raise.py](./err_raise.py)
  - [err_reraise.py](./err_reraise.py)
  - 练习
    - [debug_ex.py](./debug_ex.py)
- 12.2
  - [print2debug.py](./print2debug.py)
  - [do_assert.py](./do_assert.py)
  - [do_logging.py](./do_logging.py)
  - [log2file.py](./log2file.py)
  - [do_pdb.py](./do_pdb.py)
- 12.3
  - [mydict.py](./mydict.py)
  - [mydect_test.py](./mydict_test.py)
  - 练习
    - [test_student.py](./test_student.py)
- 12.4
  - [mydict2.py](./mydict2.py)
  - 练习
    - [doctest_fact.py](./doctest_fact.py)

# 12.1 错误处理

在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数`open()`，成功时返回文件描述符（就是一个整数），出错时返回`-1`

Python所有的错误都是从BaseException类派生的，常见的错误类型和继承关系看这里:

https://docs.python.org/3/library/exceptions.html#exception-hierarchy

错误是`class`，捕获一个错误就是捕获到该class的一个实例，并且它不是凭空产生的，而是有意创建并抛出的。可以根据需要定义一个错误的class，选择好继承关系并用`raise`语句抛出，但在Python已有内置错误类型的情况下，尽量使用内置的错误类型。

Python内置的try...except...finally用来处理错误十分方便。出错时，会分析错误信息并定位错误发生的代码位置才是最关键的。

程序也可以主动抛出错误，让调用者来处理相应的错误。但是，应该在文档中写清楚可能会抛出哪些错误，以及错误产生的原因。

# 12.2 调试

程序能一次写完并正常运行的概率很小，基本不超过1%。总会有各种各样的bug需要修正。有的bug很简单，看看错误信息就知道，有的bug很复杂，我们需要知道出错时，哪些变量的值是正确的，哪些变量的值是错误的，因此，需要一整套调试程序的手段来修复bug。

写程序最痛苦的事情莫过于调试，程序往往会以你意想不到的流程来运行，你期待执行的语句其实根本没有执行，这时候，就需要调试了。

虽然用IDE调试起来比较方便，但是最后你会发现，logging才是终极武器。

# 12.3 单元测试

单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。

比如对函数abs()，我们可以编写出以下几个测试用例：

1. 输入正数，比如1、1.2、0.99，期待返回值与输入相同；
2. 输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反；
3. 输入0，期待返回0；
4. 输入非数值类型，比如None、[]、{}，期待抛出TypeError。

把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。

如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。

单元测试通过后有什么意义呢？如果我们对abs()函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。

这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。

- 单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。
- 单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。
- 单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。
- 单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。

写单元测试步骤

- 导入`unittest`模块
- 导入要测试的模块 / 类
- 定义测试类，继承自`unittest.TestCase`
- 在测试类中为想测试的功能写多个以`teat_`开头的方法，每个方法代表一个测试用例test case
- 运行测试
  - 在脚本末尾写`if __name__=='__main__': unittest.main()`，然后直接`python mydict_test.py`运行。
  - 或者，在命令行使用`python -m unittest mydict_test`（不带 .py 后缀）也可以。这样更适合批量运行很多测试。
    - 也可以指定只运行某个测试方法例如：`python -m unittest mydict_test.TestDict.test_attr`

断言
- 使用 self.assertEqual(...) 来判断某个表达式与预期值是否相等。 
- 使用 self.assertTrue(...)、self.assertFalse(...) 等判断布尔条件。 
- 使用 with self.assertRaises(SomeException): 来断言某段代码应当抛出指定类型的异常 —— 适用于测试错误／异常情况。

# 12.4 文档测试

doctest:
- 是Python 内置测试用具，用来执行写在 docstring 里的交互式示例
- docstring 里的`>>>`代码和输出既是示例又是测试

用法：
- 在函数 / 类的 docstring 中写交互式示例：
  - ```py
    >>> add(1, 2)
    3
    ```
- 在文件末尾追加：
  - ```py
    if __name__ == '__main__':
        import doctest
        doctest.testmod()
    ```
- 运行脚本，doctest 会自动验证示例是否与真实输出一致。

使用规则：
- 输出必须完全匹配，包括空格、引号等。
- 可用`...`作为通配符匹配长输出或异常堆栈。
- 示例既能测试返回值，也能测试异常。

场景：
- 适合简单函数、库的轻量级测试。
- 示例既是文档又是测试，可避免文档与代码不一致。
- 不适合复杂逻辑、大量状态或动态输出的场景。

doctest非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含doctest的注释提取出来。用户看文档的时候，同时也看到了doctest。